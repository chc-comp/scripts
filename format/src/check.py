import z3
from sets import Set
from util import Exc, is_pred_app, foreach_expr


class FoundUF(Exception):
    def __init__(self):
        ()


class FoundQuant(Exception):
    def __init__(self):
        ()


def i_node_check(expr):
    if z3.is_quantifier(expr):
        raise FoundQuant
    elif is_pred_app(expr):
        raise FoundUF


def i_formula(expr):
    """Formulas generated by z3 should respect the rules. Can only return
    `True` or raise an exception."""
    try:
        foreach_expr(i_node_check, expr)
    except FoundUF:
        raise Exc(
            'Illegal i_formula: found uninterpreted symbol in i_formula'
        )
    except FoundQuant:
        raise Exc(
            'Illegal i_formula: only ground expressions are allowed'
        )
    return True


def u_predicate(expr, distinct_vars):
    """Returns True if expr is a valid u_predicate, False if it's not a
    predicate application, and raises an exception if it's an invalid predicate
    application.

    Argument `distinct_vars` forces to check that all arguments are
    distinct."""
    if is_pred_app(expr):
        vars = Set([])
        for index, kid in enumerate(expr.children()):
            if not z3.is_var(kid):
                raise Exc(
                    'Argument {} of application of {} '
                    'is not a variable: {}'.format(
                        index, expr.decl().name(), kid.sexpr()
                    )
                )
            if distinct_vars and kid in vars:
                raise Exc(
                    'Illegal predicate application in head: all arguments '
                    'need to be distinct variables'
                )
            vars.add(kid)
        return True
    else:
        return False


def get_implication_kids(expr, quant_okay):
    if z3.is_quantifier(expr) and expr.is_forall():
        if quant_okay:
            return get_implication_kids(expr.body(), False)
        else:
            raise Exc(
                'Illegal chc: nested foralls'
            )
    elif expr.decl().kind() == z3.Z3_OP_IMPLIES:
        return expr.children()
    else:
        raise Exc(
            'Illegal chc: '
            'expected forall or implication, got {}'.format(expr.sexpr())
        )


def check_chc_tail(expr):
    """Checks that predicate declarations are first, and that there's only one
    i_formula after them."""
    if z3.is_const(expr) \
    or z3.is_var(expr) \
    or expr.decl().kind() != z3.Z3_OP_AND:
        raise Exc(
            'Illegal tail: expected conjunction, got {}'.format(
                expr.sexpr()
            )
        )
    else:
        i_formula_count = 0
        for kid in expr.children():
            if u_predicate(kid, False):
                if i_formula_count > 1:
                    raise Exc(
                        "Illegal tail: "
                        "predicate application(s) appears after i_formula"
                    )
            elif i_formula(kid):
                i_formula_count += 1
            else:
                raise Exc(
                    "Illegal conjunct in tail: {}".format(kid.sexpr())
                )
        if i_formula_count > 1:
            raise Exc(
                (
                    "Illegal tail: expected 0 or 1 i_formula, "
                    "got {}"
                ).format(i_formula_count)
            )
    return True


# Returns true if the head is an i_formula (query clause)
def check_chc_head(expr):
    if u_predicate(expr, True):
        return False
    elif expr == z3.BoolVal(False):
        return True
    else:
        raise Exc(
            'Illegal head: {}'.format(expr.sexpr())
        )


# Return true if the clause is a query.
def check_chc(expr):
    kids = get_implication_kids(expr, True)
    check_chc_tail(kids[0])
    is_query = check_chc_head(kids[1])
    return is_query


def check_chcs(exprs):
    query_count = 0
    for index, expr in enumerate(exprs):
        try:
            is_query = check_chc(expr)
        except Exc as e:
            raise Exc(
                'While checking clause #{}\n{}'.format(index, e.value)
            )
        if is_query:
            query_count += 1
        elif not is_query and query_count > 0:
            raise Exc(
                'Illegal benchmark: '
                'query clause is not the last clause'
            )
    if query_count != 1:
        raise Exc(
            'Illegal benchmark: '
            'expected one query clause, found {}'.format(query_count)
        )
